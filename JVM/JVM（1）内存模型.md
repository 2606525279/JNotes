---
typora-root-url: JVM（1）内存模型
---

# JVM内存分布

![JVM 内存](/clipboard-1578317326416.png)

**JVM 内存区域主要分为：**

*   线程私有区域【**程序计数器、虚拟机栈、本地方法区**】
*   线程共享区域【**JAVA 堆、方法区**】
*   直接内存。

**线程私有数据区域生命周期与线程相同，依赖用户线程的启动/结束 而 创建/销毁**

**线程共享区域随虚拟机的启动/关闭而创建/销毁。线程共享区域随虚拟机的启动/关闭而创建/销毁。**





![内存分布](/clipboard-1578317375718.png)







# 堆(Heap-线程共享）

**是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中**，也是垃圾收集器进行垃圾收集的最重要的内存区域。

由于现代 VM 采用**分代收集算法**，因此 Java 堆从 GC 的角度还可以细分为: **新生代**(*Eden 区*、*From Survivor 区*和 *To Survivor 区*)和**老年代。**

**JDK8 时字符串池和类的静态变量放入 java 堆中**



**JVM 运行时内存**

Java 堆从 GC 的角度还可以细分为: **新生代**(*Eden 区*、*From Survivor 区*和 *To Survivor 区*)和**老年代**。

![img](/clipboard.png)



## 新生代

是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。

**1. Eden 区**

Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。

**2. ServivorFrom**

上一次 GC 的幸存者，作为这一次 GC 的被扫描者。

**3. ServivorTo**

保留了一次 MinorGC 过程中的幸存者。



## **老年代**

主要存放应用程序中生命周期长的内存对象。

老年代的对象比较稳定，所以 **MajorGC** 不会频繁执行。在进行 **MajorGC 前一般都先进行了一次 MinorGC**，使得有新生代的对象晋身入老年代，**导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时**也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 `OOM（Out of Memory）`异常。

## 永久代

指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息，Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同，**GC 不会在主程序运行期对永久区域进行清理**。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。



# 方法区(线程共享）

和堆区一样，别名 Non-heap （**非堆**）， 又被称为**永久代(Permanent Generation)**，**线程共享**，用于**存储被 JVM 加载的类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据. 

**运行时常量池**（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是**常量池：用于存放编译期生成的各种字面量和符号引用**，这部分内容将在**类加载后**存放到方法区的运行时常量池中。



HotSpot VM把GC分代收集扩展至方法区，即**使用Java堆的永久代来实现方法区**，这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存，而不必为方法区开发专门的内存管理器（**永久代的内存回收的主要目标是针对常量池的回收和类型的卸载**，因此收益一般很小）。



# Metaspace(元空间）

**在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代**。

元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。因此，默认情况下，元空间的大小仅受本地内存限制。

**类的元数据放入 native memory，字符串池和类的静态变量放入 java 堆中**，这样可以加载多少类的元数据就不再由 MaxPermSize 控制，而由系统的实际可用空间来控制。



# 虚拟机栈(线程私有)

虚拟机栈是描述java方法执行的内存模型，其特点如下：

*   每个方法在执行的同时都会创建一个**栈帧**（Stack Frame）用于存储局部变量、操作数栈、动态链接、方法出口等信息。
*   每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
*   **线程私有；生命周期与线程相同**



**栈帧（ Frame）**

是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。



**局部变量表**

*   存储编译期可知的各种 **基本数据类型、对象引用类型**（引用指针或句柄）和 **returnAddress类型**（指向了一条字节码指令的地址）；
*   在编译期完成内存分配，当内存不足时，会抛出两种异常：SOF 异常、OOM异常；**SOF 异常** `（StackOverflowError）`：线程请求的栈深度大于虚拟机允许的深度时抛出；**OOM异常** `（OutOfMemoryError）`：无法申请到足够内存时抛出





# 本地方法区(线程私有)

本地方法区和 Java Stack 作用类似，区别是虚拟机栈为执行 Java 方法服务，而本地方法栈则为Native 方法服务，如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用，那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。

也会抛出两种异常：SOF 异常、OOM异常



# 程序计数器(线程私有)

一块较小的内存空间，**是当前线程所执行的字节码的行号指示器**，每条线程都要有一个独立的程序计数器，这类内存也称为 ”线程私有“ 内存。

正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。

这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。





# 内存分配策略

Java 程序运行时的内存分配策略有三种

*   静态分配：静态存储区（也称方法区），静态数据、全局 static 数据和常量
*   栈式分配：栈区，方法体内的局部变量（其中包括基础数据类型、对象的引用）
*   堆式分配：堆区，new 出来的内存，也就是对象的实例



## 堆内存分配策略

Eden区存活对象进入Survivor区（Eden肯定会被清空），**大对象（长字符串或数组，byte[] 就是典型）进入直接进入老年代；如果Survivor区无法提供足够的内存，则通过分配担保机制提前进入老年代**

*   Survivor区中存活年龄**大于等于15**的对象直接进入老年代（每次Minor GC对象年龄加1）
*   Survivor区**同年龄的对象大小总和大于Survivor空间的一半时**，其他年龄大于或等于该年龄的对象直接进入老年代，年龄不必等到15
*   当发生MinorGC时，**survivor空间不够时**，需要老年代分配担保，让survivor无法容纳的对象进入老年代
*   年轻代空间回收称作 Minor GC  ，发生频繁，老年代的垃圾回收称作 Full GC/Major GC



**Minor GC** ：年轻代进行的垃圾回收，非常频繁，一把回收速度较快

**Major GC**：老年代进行的垃圾回收，发生一次MajorGC至少伴随一次Minor GC，一般比Minor GC慢10倍

**Full GC**：整个堆内存进行垃圾回收，很多时候是Major GC



**MinorGC 的过程（复制->清空->互换）采用复制算法**。

对象创建时，会在Eden区分配内存，Eden区内存不够，触发**Minor GC**（年轻代的垃圾回收）

*   **1：eden、servicorFrom 复制到** **ServicorTo，年龄+1**

首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；

*   **2：清空 eden、servicorFrom**

然后，清空 Eden 和 ServicorFrom 中的对象；

*   **3：ServicorTo 和 ServicorFrom 互换**

最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。





**Full GC 的触发条件:**

*   调用System.gc()， 建议虚拟机执行 Full GC，不一定正在执行，不推荐
*   老年代不足时，常见场景大对象、长期存活的对象直接进入老年代时内存不足，导致频繁GC
*   为 survivor 的空间担保失败。



**永久代主要回收：废弃常量和无用的类**，废弃常量和无用的类的判断方式：

*   **废弃常量：** 该常量没有任何对象进行引用，就会被回收。
*   **无用的类：** 该类的所有实例都已经被回收，该类的ClassLoader已经被回收，该类的Class对象没有被引用，无法完成通过反射访问该类 



