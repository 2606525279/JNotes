# 查找算法

# 1、顺序查找

## 算法简介

​       顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。

## 基本思路

​       从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。

## 优缺点

​    缺点：是当n 很大时，平均查找长度较大，效率低；    优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。





# 2、二分查找

## 算法简介

​    二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。    这种查找算法每一次比较都使查找范围缩小一半。

## 算法描述 

给予一个包含 n个带值元素的数组A 

*   1、 令 L为0 ， R为 n-1 ；       
*   2、 如果L>R，则搜索以失败告终 ；        
*   3、 令 m (中间值元素)为  ⌊(L+R)/2⌋；        
*   4、 如果 Am<T，令 L为 m + 1 并回到步骤二 ；        
*   5、 如果 Am>T，令 R为 m - 1 并回到步骤二；

## 复杂度分析 

​    时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为 O(logn)     空间复杂度：O(1)



## 代码实现

```java
//二分查找，递归版本
public class BinarySearch2{
    //递归查找
    public static int binarysearch(int[] a,int value,int low,int high){
        int mid = (low + high)/2;
        if(value == a[mid]){
            return mid;
        }else if(value < a[mid])
            return binarysearch(a,value,low,mid - 1);
        }else if(value > a[mid])
            return binarysearch(a,value,mid + 1,high);	
        }
        return -1;
    }
	//循环查找
    public static int binarysearch(int[] a,int value){
		int left=0;
		int right=a.length-1;
		int middle=0;
		while(left<=right) {
			middle=(left+right)/2;
			if(value == a[middle]){
	            return middle;
	        }else if(value < a[middle]) {
	        	left=middle - 1;
	        }else if(value > a[middle]) {
	        	right=middle + 1;	
	        }
		}
		return middle;
    }
	public static void main(String[] args) {
		//int[] a = {1,4,2,9,8,6,7,0,3,5}
		int[] a = {0,1,2,3,4,5,6,7,8,9};
		System.out.println(binarysearch(a,4,0,a.length-1));
	} 
}

```



# 3、插值查找

## 算法简介

​    插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])\*(high-low)。    时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。

## 算法思想 

​    基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。     注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。

## 复杂度分析 

​    时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要 O（n）。    空间复杂度：O（1）。



https://blog.csdn.net/abcdef314159/article/details/85097414





### 4、斐波那契查找

### 5、树表查找

### 6、分块查找

### 7、哈希查找