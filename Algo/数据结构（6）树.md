---
typora-root-url: 数据结构（6）树
---

树：由根结点和若干子结点构成的结合体

![](2019-06-05_205958.png)

## 基础术语

*   **节点的度**：指一个结点的子树个数，
*   **树的度**：一棵树中，最大的节点的度称为树的度；

*   **叶结点或终端节点**：指度为零的结点，即没有子树的结点
*   **非终端节点或分支节点**：度不为0的节点；
*   **双亲节点或父节点**：若一个节点含有子节点，则这个节点称为其子节点的父节点；
*   **孩子节点或子节点**：一个节点含有的子树的根节点称为该节点的子节点；
*   **兄弟节点**：具有相同父节点的节点互称为兄弟节点；
*   **节点的层次**：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
*   **树的高度或`深度`**：树中节点的最大层次；
*   **堂兄弟节点**：双亲在同一层的节点互为堂兄弟；
*   **节点的祖先**：从根到该节点所经分支上的所有节点；
*   **子孙**：以某节点为根的子树中任一节点都称为该节点的子孙。
*   **森林**：由m（m>=0）棵互不相交的树的集合称为森林；

![](2019-06-24_212644.png)

## 树分类

二叉树：有n(n>=0) 结点组成的有限集合。此集合或为空、或由一个跟结点加上两个分别称为左右子树的，互不相交的二叉树组成。

*   二叉树第 i 层上的结点数最多为 2 ^i-1^
*   高度为 k 的二叉树最多有2^k^-1 个几点

![](2019-06-05_211519.png)

分类

*   无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;

*   有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树；

*   二叉树：每个节点最多含有两个子树的树称为二叉树；

*   完全二叉树：指一棵二叉树最下面的两层结点的度数可以小于 2 ，并且最下一层上的结点数都集中在该层最左边的若干位置上。

*   满二叉树：每层的结点数都达到最大值即 深度为  k 且有 2^k^-1 个结点

*   霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；
*   平衡二叉树：又称AVL树；
    *   左子树和右子树都是平衡二叉树
    *   左子树和右子树的深度（高度）之差的绝对值不超过1。
    *   常用实现方法有 **红黑树**、AVL、替罪羊树、Treap、伸展树

![](2019-06-05_213234.png)

![](2019-06-05_213224.png)





## 二叉树存储结构

### 顺序存储

*   顺序存储指：不管给定的二叉树是不是完全二叉树，都看作完全二叉树，即按完全二叉树的层次次序（从上到下，从左到右）把各个结点依次存入数组中

![](2019-06-05_213755.png)

![2019-06-05_214742](2019-06-05_214742.png)

### 链式存储

链式存储中，每个节点由数据员和三个指针组成，即链表结构 在加一个 尾指针

![](2019-06-05_215227.png)



## 遍历树

遍历树四种基本的遍历思想为：

前序遍历：根结点 ---> 左子树 ---> 右子树

中序遍历：左子树---> 根结点 ---> 右子树

后序遍历：左子树 ---> 右子树 ---> 根结点

层次遍历：仅仅需按层次遍历就可以

![](20150204101904649)

前序遍历：1  2  4  5  7  8  3  6

中序遍历：4  2  7  5  8  1  3  6

后序遍历：4  7  8  5  2  6  3  1

层次遍历：1  2  3  4  5  6  7  8



**代码实现**

```java
//采用递归方式：---->>>>>>>>>>>>>
//前序遍历
public void preOrderTraverse1(TreeNode root) {  
        if (root != null) {  
            System.out.print(root.val+"  ");  
            preOrderTraverse1(root.left);  
            preOrderTraverse1(root.right);  
        }  
}

//中序遍历
public void inOrderTraverse1(TreeNode root) {  
        if (root != null) {  
            inOrderTraverse1(root.left);  
            System.out.print(root.val+"  ");  
            inOrderTraverse1(root.right);  
        }  
} 
//后续遍历
public void postOrderTraverse1(TreeNode root) {  
        if (root != null) {  
            postOrderTraverse1(root.left);  
            postOrderTraverse1(root.right);  
            System.out.print(root.val+"  ");  
        }  
} 


//层次遍历
public void levelTraverse(TreeNode root) {  
        if (root == null) {  
            return;  
        }  
        LinkedList<TreeNode> queue = new LinkedList<>();  
        queue.offer(root);  
        while (!queue.isEmpty()) {  
            TreeNode node = queue.poll();  
            System.out.print(node.val+"  ");  
            if (node.left != null) {  
                queue.offer(node.left);  
            }  
            if (node.right != null) {  
                queue.offer(node.right);  
            }  
        }  
} 
```

## 平衡二叉树

![](2019-06-05_222540.png)

平衡二叉树：又称AVL树；

*   左子树和右子树都是平衡二叉树
*   左子树和右子树的深度（高度）之差的绝对值不超过1。
*   常用实现方法有 **红黑树**、AVL、替罪羊树、Treap、伸展树

AVL树同二叉排序树一样，有遍历（先序、中序、后序），最大值与最小值，插入和删除，销毁二叉树等操作，除插入和删除与二叉排序树操作不同之外，其余均与二叉排序树相同



## 红黑树

红黑树（Red Black Tree） 是一种自平衡二叉查找树

红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。

它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。

**特性：**

*   红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。

*   性质1. 节点是红色或黑色。

*   性质2. 根节点是黑色。

*   性质3 每个红色节点的两个子节点都是黑色。(**从每个叶子到根的所有路径上不能有两个连续的红色节点**)

*   性质4. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

![](9358d109b3de9c828cdb8e7c6481800a18d84382.jpg)





## B-tree

多路查找树 ( muitl-way search tree) ，其每一个结点的孩子数可以多于两个 ， 且每一个结点处可以存储多个元素。 

它的 4 种特殊形式 : 2-3 树、 2-3-4 树、 B 树和 B+树。 

B 树 (B-Tree ) 是一种平衡的多路查找树 ， 2 -3 树和 2-3-4 树都是 B 树的特例。结点最大的孩子数目称为 B 树的阶 (order) ，因此， 2-3 树是 3 阶 B 树， 2-3-4 树是 4阶B树。 



**m阶B-Tree满足以下条件：**

1、每个节点最多拥有m个子树

2、根节点至少有2个子树

3、分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）

4、所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列

