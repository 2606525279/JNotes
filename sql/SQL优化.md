# 表设计原则

## 1、类型选择

原则：尽量选用可以正确存储数据的最小类型

特点：更小的数据类型具备速度快、占用更少的磁盘、内存、CPU缓存，CPU 处理周期



遵守准则：

1.  **主键最好定义为增长主键**，字符字段最好不要做主键
2.  **避免NULL**，需要更多的存储空间、性能低、很难优化，推荐默认值代替null
3.  **使用TIMESTAMP而非DATETIME**，优点：TIMESTAMP只使用DATETIME一半的存储空间、并且会根据时区变化，缺点TIMESTAMP的时间范围要小
4.  **使用 decimal存储小数非 float和double**
5.  **尽量使用INT而非BIGINT**，如果非负则加上UNSIGNED（这样数值容量会扩大一倍），当然能使用TINYINT、SMALLINT、MEDIUM_INT更好。
6.  **使用枚举或整数代替字符串类型**。如性别：可以使用 `tinyint`，它比 char 更合适。枚举实际上就是TINYINT存储
7.  **尽量使用INT而非BIGINT**，如果非负则加上UNSIGNED（这样数值容量会扩大一倍），当然能使用TINYINT、SMALLINT、MEDIUM_INT更好。
8.  **尽可能的使用 varchar代替 char**，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。
9.  单表不要有太多字段，建议在20以内。
10.  尽量少用text，非用不可最好分表。



最佳实践：

*   使用MySQL 内建的类型来存储日期和时间，而非字符串类型
*   整型(UNSIGNED INT)存储IP地址，MySQL提供INET_ATON把字符串的IP转换成整数，以及INET_NTOA把整数IP转换成字符串
*   char 类型适合存储密码的MD5值，因为这是一个定长值



# SQL 优化

- 避免select *，将需要查找的字段列出来。
- 控制 in 的个数建议在200内，建议 exists 代替 in
- 使用连接（join）来代替子查询，执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表。但是尽量少用JOIN 查询，尽量单表查询
- 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，如日期转换，date_format(create_time,'%Y-%m-%d') = '2019-08-02'
- 使用多列索引时注意顺序和查询条件保持一致，同时删除不必要的单列索引
- 避免%xxx式查询
- 当只要一行数据时使用 LIMIT 1



# 索引设计原则

1. **索引的列选择查询频繁的列，在where，group by，order by，on从句中出现的列**，⽽不是出查询结果集总的列
2. **索引的列的基数越⼤，索引的效果越好**。例如，存放出⽣⽇期的列具有 不同值，很容易区分各⾏。值分布很稀少的字段不适合建索引，如⽤来记录性别的列，只含有“M”和“F”，则对此列进⾏索引没有多⼤⽤处
3. **使⽤短索引。**如对字符串列进⾏索引，应该指定⼀个前缀长度
4. **最左前缀原则**。联合索引根据最左原则可起⼏个索引的 作⽤
5. 避免在WHERE子句中对字段进行NULL值判断
6. 字符字段只建前缀索引





# 索引失效

## 最左原则

对于联合索引，多个索引列必须从左至右的出现在where中，

如：索引（a，b，c）

* 索引有效：where a=xx and b=xx  或者 where b=xx and a=xx
* 索引无效：where b=xx and c=xx



## 模糊查询

字符串类型的索引列在where 中使用了like和通配符%，如下：当%位于最左边的索引列时无法使用索引，否则可以继续使用索引。所以避免%xxx式查询

如：索引（a，b，c）

- 索引有效：where a=xx and b like '%xx '
- 索引有效：where a 'xx% ' and b=xx
- 索引无效：where a '%xx ' and b=xx



## 隐式转换

数据类型隐式转换是指查询条件中的索引列对应的值的类型和列的类型不一致；

**数字转字符串类型**，联合索引时，在最左原则下生效

如 ：索引列  a  为 varchar 类型

* 索引有效：where a = '1'
* 索引无效：where a = 1

如 ：索引列  a  为 int  类型

- 索引有效：where a = '1'  或者   where a =  1

如 ：索引列（a,b）  a  为 int  类型

- 索引无效：where a = '1'  

如 ：索引列（a,b）  b  为 int  类型

- 索引有效：where b = '1'  and a = ''



## OR 查询

innodb引擎，使用OR 查询所有列会是索引失效，OR 两边的列都是不能使用索引

但是，可以使用`覆盖索引`，或者使用`UNION替代`



## 函数使用

索引列参与到函数计算时索引失效

**简单加减运算**

不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，负责索引会失效

如：索引（a）

* 索引无效 ：a /2 = 10  可以改为 a = 10*2

**索引列参与到MySQL函数**

如：substring(name,1,3)=’abc’



## 空值判断

索引列在使用 `is null`  或者 `is not  null` 判断时，索引会失效



## 注意

以下说法在网上很流行，但经过小编测试，发现说法有误

1、尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

无论哪种InnoDB还是MyISAM 引擎，使用HASH索引或者BTREE 索引，`!=`或`<>`操作符不会使索引失效



2、in 和 not in 也要慎用，否则会导致全表扫描

经测试，该说法有误





# 分表分区分库

## 分表

- 分表就是把一张大表，按照如上过程都优化了，还是查询卡死，那就把这个表分成多张表，把一次查询分成多次查询，然后把结果组合返回给用户。
- 分表分为**垂直拆分**和**水平拆分**，通常以某个字段做拆分项。比如以id字段拆分为100张表：表名为 tableName_id%100。
- 但：分表需要修改源程序代码，会给开发带来大量工作，极大的增加了开发成本，故：只适合在开发初期就考虑到了大量数据存在，做好了分表处理，不适合应用上线了再做修改，成本太高！！！故不建议采用。

## 分库

- 把一个数据库分成多个，建议做个读写分离就行了，真正的做分库也会带来大量的开发成本，得不偿失！不推荐使用。

![最近很火的MySQL：抛开复杂的架构设计，MySQL优化思想基本都在这](assets/c1dca4018a0b4818a52c5ab26df8fbeb.jpg)