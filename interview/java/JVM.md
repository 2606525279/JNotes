

------

# JVM

# 一、Java内存模式

## 1、Java 堆

*   是内存中最大的一块，**存放对象实例和数组，线程共享** ，是垃圾收集的主要区域（"GC 堆"）
*   采用分代收集算法，可分为：**新生代、老年代** ，
*   新生代：又分 Eden 、Survivor区（survivor区里面分为from和to区，内存回收时，如果用的是复制算法，从from复制到to）；
*   在堆无法再扩展时抛出OOM异常（OutOfMemoryError）；可通过-Xmx和-Xms控制
*   jdk 1.7 时将**字符串常量池**从方法区移出，存放在堆中



## 2、方法区

**存储内容：**

*   和堆区一样，**线程共享**，**存放被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等信息**； 
*   别名 Non-heap （**非堆**）， 又被称为**永久代**

*   包含**运行时常量池** ：存储编译期生成的各种`字面量`和`符号引用`，在类加载后进入运行时常量池；
*   无法再扩展时抛出OOM异常
*   具有**动态性**的，常量在非编译期也可以放入，比如：String类的intern()方法

*   JDK 1.7时**常量池移出永久代，存放在堆中了**
*   JDK 1.8 取消方法区，改为元空间，存储在本地内存（还包含一个直接内存）



**Class文件** ： 除了有类的版本、字段、方法、接口等描述信息外，还有一个 **常量池**，在类加载后进入方法区的运行时常量池存放。

**String类的intern()方法**：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象引用；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。

**Metaspace（元空间）**

*   在JDK1.8中，**永久代已经不存在**，存储的类信息、编译后的代码数据等已经移动到了MetaSpace（元空间）中，**常量池从永久代中分离到堆中**
*   元空间直接占用的**本地内存**（NativeMemory），**并不在虚拟机中**

------

## 3、虚拟机栈

*   每个方法在执行时，都会创建一个栈帧，用来**存储局部变量表、操作数栈、动态链接、方法出口等信息**
*   每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

**特点：线程私有；生命周期与线程相同**



**局部变量表**

*   存储编译期可知的各种 **基本数据类型、对象引用类型**（引用指针或句柄）和 **returnAddress类型**（指向了一条字节码指令的地址）；
*   在编译期完成内存分配
*   可抛出两种异常：SOF 异常、OOM异常

*   **SOF 异常（StackOverflowError）** ：线程请求的栈深度大于虚拟机允许的深度时抛出
*   **OOM异常（OutOfMemoryError）** ：无法申请到足够内存时抛出

## 4、本地方法栈

*   与虚拟机栈类似，是为执行native方法（非java代码）服务的
*   也会抛出两种异常：SOF 异常、OOM异常

## 5、程序计数器

*   是当前线程所执行的字节码的行号指示器，**`线程私有`**

*   通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能



## 6、直接内存

*   堆外内存，和元空间一起在本地内存；
*   JDK 1.4 新加入的NIO类，基于通道channel与缓冲区buffer的I/O方式
*   可使用native函数库直接分配，通过一个存储在java堆中的DirectByBuffer对象作为这块内存的引用进行操作
*   也会抛出OOM异常

## 7、内存分配策略

Java 程序运行时的内存分配策略有三种

*   静态分配：静态存储区（也称方法区），静态数据、全局 static 数据和常量
*   栈式分配：栈区，方法体内的局部变量（其中包括基础数据类型、对象的引用）
*   堆式分配：堆区，new 出来的内存，也就是对象的实例



### 1> 堆内存分配策略

*   对象创建时，会在Eden区分配内存，Eden区内存不够，触发Minor GC，年轻代的垃圾回收
*   Eden区存活对象进入Survivor区（Eden肯定会被清空），大对象（长字符串或数组，byte[] 就是典型）进入直接进入老年代；如果Survivor区无法提供足够的内存，则通过分配担保机制提前进入老年代
*   Survivor区中存活年龄大于等于15的对象直接进入老年代（每次Minor GC对象年龄加1）
*   Survivor区同年龄的对象大小总和大于Survivor空间的一半时，其他年龄大于或等于该年龄的对象直接进入老年代，年龄不必等到15
*   当发生MinorGC时，survivor空间不够时，需要老年代分配担保，让survivor无法容纳的对象进入老年代
*   年轻代空间回收称作 **Minor GC ** ，发生频繁，老年代的垃圾回收称作 **Full GC/Major GC**



Minor GC ：年轻代进行的垃圾回收，非常频繁，一把回收速度较快

Major GC：老年代进行的垃圾回收，发生一次MajorGC至少伴随一次Minor GC，一般比Minor GC慢10倍

Full GC：整个堆内存进行垃圾回收，很多时候是Major GC



**Full GC 的触发条件:**

*   调用System.gc()， 建议虚拟机执行 Full GC，不一定正在执行，不推荐
*   老年代不足时，常见场景大对象、长期存活的对象直接进入老年代时内存不足，导致频繁GC
*   为 survivor 的空间担保失败。



### 2> 对象的创建方式

**4种方式**  ：new关键字、反射、克隆、序列化

**对象创建过程：**

*   当需要创建对象时，如：遇到一条new指令，会先检查在常量池中是否有该类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有先执行类加载过程
*   检查通过后，虚拟机将为新生对象分配内存，内存大小在类加载完就可以确定了。



**内存分配2种方式**：指针碰撞、空闲列表

*   **指针碰撞**：在内存是绝对规整情况下，内存分已用内存和空闲内存，中间由一个指针做为分界点的指示器相连；当需要分配内存时，指针向空闲内存移动一段与对象大小相等的距离
*   **空闲列表**：在内存不规整的情况下，虚拟机有一个维护列表，用于记录哪块内存可用；在分配时，从列表找一块空间足够的内存分给对象实例；

分配方式由堆是否规整决定，而java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。

采用指针碰撞情况：使用Serial、ParNew等带有Compact过程的收集器时

采用空闲列表情况：使用CMS（内存管理系统：基于Mark-Sweep算法的收集器）

### 3> JVM启动参数

**-Xmx** ：设置最大堆容量

**-Xms** ：设置初始堆容量

**-Xmn** ：新生代大小

**-Xss** ：参数设定每个线程的栈大小

-XX:newRatio ：新生代与老年代的比例

-XX:SurvivorRatio ：Eden区与Survivor的比例

-XX:PermSize ：永久代的初始大小

-XX:MaxPermSize ：永久代的最大空间

-XX:MaxTenuringThreshold：设置垃圾最大年龄

-XX:MaxDirectMemorySize  ：直接内存，如果不指定与Xmx  一样



Eclipse Memory Analyzer：Eclipse 插件，Java内存分析器，可帮助您查找内存泄漏并减少内存消耗。

------

# 二、类的加载

## 1、类的加载

虚拟机将描述类的数据从.class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型

**数组类本身不通过类加载器创建，由Java虚拟机直接创建，但数组类的元素类型由加载创建（基本数据类型除外）**



**加载.class文件的方式：**

*   从本地系统中直接加载
*   通过网络下载.class文件
*   从zip，jar等归档文件中加载.class文件
*   从专有数据库中提取.class文件
*   将Java源文件动态编译为.class文件



## 2、类的生命周期

**加载、验证、准备、解析、初始化、使用和卸载7个阶段**；验证准备解析3部分统称**连接**；

**加载：获取二进制字节流，类的静态信息存储至方法区，在内存中生成一个class类对象**

此过程完成3件事

*   通过全限定名获取此类的二进制字节流
*   将字节流所代表的静态存储结构转化为方法区的运行时数据结构
*   在内存中生成此类的Class对象（Hotspot虚拟机，class对象存储在方法区），作为方法区这个类的各种数据访问入口

**验证：校验二进制字节流是否符合JVM标准，大致分 4 阶段：**

*   文件格式验证：
*   元数据验证：
*   字节码验证：
*   符号引用验证：

**准备：类的静态变量分配内存，并设置类变量的初始值**

*   数据类型默认**零值，final修饰过的直接赋值**

**解析：把类中的符号引用转换为直接引用**

*   主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符 7 类符号引用
*   符号引用：以一组符号（任一形式字面值，）描述目标的引用
*   直接引用：句柄或直接指针描述目标引用

**初始化：**

*   就是执行类构造器<clinit>（）的方法过程
*   <clinit>（）是由编译期收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的

**卸载：**执行垃圾回收

------

**结束生命周期方式：**

*   执行了System.exit()方法
*   程序正常执行结束
*   程序在执行过程中遇到了异常或错误而异常终止
*   由于操作系统出现错误而导致Java虚拟机进程终止

------

**注意：**

**数组类加载：**

数组类本身不通过类加载器创建，由Java虚拟机直接创建，但数组类的元素类型由加载创建（基本数据类型除外）



**如果类的字段属性同时被final和static修饰，那么在准备阶段变量被初始化为指定的值。**

*   假设上面的类变量value被定义为： public static final int value = 3；

    编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中

------

扩展：

<clinit>（）：是编译器自动收集类中的所有类变量的赋值动作和静态块中的语句合并产生。这也是为什么静态块最先输出的原因；

**JVM初始化步骤：**
1、假如这个类还没有被加载和连接，则程序先加载并连接该类
2、假如该类的直接父类还没有被初始化，则先初始化其直接父类
3、假如类中有初始化语句，则系统依次执行这些初始化语句



## **3、类初始化的时机**

*   使用new 实例化对象时
*   调用静态变量时（常量除外）、静态方法 
*   通过反射调用 
*   初始化一个类如果父类没有初始化，先触发父类的初始化 
*   执行main方法的启动类

注意：

1.  子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。。对于静态字段，只有直接定义这个字段的类才会被初始化.
2.  通过数组定义来引用类，不会触发类的初始化
3.  访问类的常量，不会初始化类



**类加载分类：**

*   静态加载：
    *   编译时刻加载的类是静态加载类
    *   **new关键字来实例对象**，编译时执行
*   动态加载：
    *   运行时刻加载的类是动态加载类。
    *   **反射方式**加载就是动态加载



**不会初始化的情况**

*   通过子类引用父类的静态字段，不会导致子类初始化，**只有定义了这个静态字段的类才会被初始化**
*   通过数组定义的引用类，不会触发此类的初始化
*   常量在编译期会存入到调用类的常量池，本质上不会直接引用到定义常量的类，因此也不会触发定义常量的类的初始化

**接口和类的的初始化区别：**只需要真正使用到的父接口初始化，不需要所有父接口都初始化

------

## 3、类加载器

### **1. 类与类加载器区别**

*   每个类加载器都独立的类名称空间，一个类可以由不同的加载器加载，
*   **两个类是否相等，取决于是否是同一个类加载器加载，**

### **2. 类加载器种类**

*   启动类加载器：负责加载存放在`JDK\jre\lib`下 ，像rt.jar的加载
*   扩展类加载器：`JDK\jre\lib\ext`类的加载
*   应用程序类加载器：它负责加载用户类路径（ClassPath）所指定的类
*   自定义加载器

### **3. JVM类加载机制**

*   **全盘负责**，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
*   **父类委托**，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
*   **缓存机制**，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

### **4. 双亲委派模型**

加载器之间相互配合进行加载的层次关系，其**原理是**：一般不会自己尝试加载，而请求委派给父类加载，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器无法加载，才自己尝试加载



**双亲委派模型优点**：

*   避免同一个类被多次加载；
*   每个加载器只能加载自己范围内的类
*   保证java程序的稳定运行

**使用双亲委派模型原因**

*   例如 java.lang.Object,无论哪一个类加载器要加载该类,最终都是委托给处于顶端的启动类加载器,因此object在程序的各种类加载器环境中都是同一个类.
*   如果没有使用双亲委派模型，那么假如用户自定义了一个称为java.lang.Object的类，并放在classPath中,那么系统将会出现多个不同的Object类，则java类型体系中最基础的行为都无法保证.



**破坏双亲委派模型**：

3次被破坏，

*   第一次：在jdk 1.2 之后ClassLoader新增了一个protected findClass()方法。不在提倡重写loadClass()方法，要求类加载逻辑写到findClass()方法中，来保证符合双亲委派规则
*   第二次：添加了线程上下文加载器。来使JNDI 加载所需要的SPI（Service Provider Interface）代码，所有涉及SPI的加载动作都是这种方式，如：JNDI/JDBC/JCE/JAXB/JBI
*   第三次由用户对程序动态性的追求而导致的，如：代码热替换、模块热部署等

------

**扩展：**

**类加载有三种方式：**

*   命令行启动应用时候由JVM初始化加载
*   通过Class.forName()方法动态加载
*   通过ClassLoader.loadClass()方法动态加载

**用户自定义类加载器：**

*   如果要符合双亲委派规范，则**重写findClass方法**（用户自定义类加载逻辑）；
*   要破坏的话，**重写loadClass方法**(双亲委派的具体逻辑实现)。



**反射中Class.forName()和ClassLoader.loadClass()的区别**

*   Class.forName：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
*   classloader只将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。
*   Class.forName(name,initialize,loader)带参数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象。



**启动类加载器：**

*   C++实现的，是虚拟机的一部分，其他的加载器都是java实现的

**热部署**

*   是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为
*   热部署步骤：
    *   1、销毁自定义classloader(被该加载器加载的class也会自动卸载)；
    *   2、更新class
    *   3、使用新的ClassLoader去加载class 

**Class被卸载**

JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：

*   该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。
*   加载该类的ClassLoader已经被GC。
*   该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法



------

思考：

可以不可以自己写个String类

答案：不可以，因为 根据类加载的双亲委派机制，会去加载父类，父类发现冲突了String就不再加载了;



------

### 5. 对象的访问

对象的访问2种方式，使用过栈上的**直接指针**或**句柄**进行的，即对象引用地址

*   句柄：使用句柄访问，Java堆会划分出一块内存做句柄池，存储对象的句柄地址，包含对象实例数据与类型数据各自的具体地址信息
*   直接指针：直接就是对象地址

**直接指针和句柄方式的区别：**

直接指针：速度快，句柄：数据稳定

Hotspot： 使用直接指针进行对象访问



------

# 三、GC 回收机制

------

## 1、GC 对象

### 1> 对象存活判定

判断对象是否存活一般有两种方式：**引用计数算法，可达性分析算法**

**引用计数：**每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。

**可达性分析**（Reachability Analysis）：通过一系列的名为“GC Root”的对象作为起点，如果与对象之间没有任何引用链相连，则证明此对象是不可用的

**GC Roots的对象分：**

*   虚拟机栈中引用的对象、
*   方法区中类静态属性和常量的引用的对象、
*   本地方法栈中JNI（native接口）引用的对象。



**对象GC标记过程**

**第一次标记：**

*   如果对象在可达性分析后没有与GC Roots相连接的引用链，将**第一次被标记**，并进行一次筛选，筛选条件为**是否有必要执行finalize()方法**，
*   没有必要执行finalize()方法，便将这对象**放置F-Queue队列**中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它（指触发这个方法）；
*   "没必要执行"的两种情况：**当对象没有覆盖finalize()**，或者此方法**已经被虚拟机调用过**

**第二次标记：**

*   稍后GC将对F-Queue中的对象进行**第二次标记**，如果对象在finalize()方法中成功拯救自己（重新与引用链上的任一对象建立关联），它将被移出“即将回收”集合，否则，被回收

总结：

*   根据向下搜索方法判断引用链不可达 
*   再判断是否有必要执行finalize()方法，
*   没有必要执行，进入f-queue队列 
*   再次判断与GCRoot有链接 
*   没有回收



------

### 2> 对象引用关系

无论通过引用计数算法还是可达性分析算法，来判读对象是否存活，都与引用相关；

引用分：**强引用、软引用、弱引用、虚引用；引用强度依次减弱**

*   强引用：**永远不会被回收**，类似“Object obj = new Object()”的引用
*   软引用： **内存不足回收** ，用来描述一些还有用但是并非必须的对象， 通过SoftReference类实现
*   弱引用： **只能生存到下一次垃圾收集之前**， 用来描述非必须的对象，通过WeakReference类实现
*   虚引用： **无影响**，无法通过虚引用获取对象实例，其目的为了能在对象被回收时收到一个系统通知，通过PhantomReference类实现

------

### 3> 永久代GC

永久代主要回收：**废弃常量和无用的类**

**废弃常量和无用的类的判断方式：**

*   **废弃常量：** 该常量没有任何对象进行引用，就会被回收。
*   **无用的类：** 该类的所有实例都已经被回收，该类的ClassLoader已经被回收，该类的Class对象没有被引用，无法完成通过反射访问该类 



------

## 3、GC 算法

共有4种：**标记-清除算法、复制算法、标记-整理算法、分代收集算法**

### 1> 标记/清除算法

*   算法分为“标记”和“清除”两个阶段

*   缺点：效率不高，**产生大量不连续的内存碎片**

![2019-05-25_221513](https://raw.githubusercontent.com/HusyCoding/static-resources/master/learning-notes-images/images/2019-05-25_221513.png)

### 2> 复制算法

*   将**内存划分为两块**，先使用一块。使用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。最开始大小是1:1 ，后来变成8:1的比例
*   缺点：
    *   **效率低** ，大量存活对象时会进行较多次复制操作。
    *   **需要分配担保**：survivor空间不足时，需要老年代进行分配担保，来保证所有对象有存活的情况
    *   **gc过程简单，运行高效** ,不需要考虑内存碎片等复杂情况

![2019-05-25_221529](https://raw.githubusercontent.com/HusyCoding/static-resources/master/learning-notes-images/images/2019-05-25_221529.png)

### 3> 标记-整理算法

*   **先标记，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存**
*   不会产生内存碎片

![2019-05-25_221541](https://raw.githubusercontent.com/HusyCoding/static-resources/master/learning-notes-images/images/2019-05-25_221541.png)

### 4> 分代收集算法

*   把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。
*   新生代中采用**复制算法** ，每次垃圾收集时都发现有大批对象死去，只有少量存活
*   老年代中采用**标记-清理 或 标记-整理算法** ，因为对象存活率高、没有额外空间对它进行分配担保



------

## 4、垃圾收集器

共有7种收集器：Serial收集器、ParNew收集器、Parallel Scavenge收集器、Serial Old 收集器、Parallel Old 收集器、CMS收集器、G1收集器

新生代收集器：Serial收集器、ParNew收集器、Parallel Scavenge收集器

### 1> Serial收集器

*   串行，单线程收集器，作用于新生代，采用复制算法
*   缺点：会造成停顿
*   Serial多线程版本：ParNew收集器，能与CMS 配合工作
*   Serial老年代版本：Serial Old 收集器

### 2>  Parallel Scavenge收集器

*   并行、多线程收集器，作用于新生代，采用复制算法

*   目标：追求可控的吞吐量；通过参数控制吞吐量和最大停顿时间
*   老年代版本：Parallel Old 收集器：多线程、标记-整理算法

### 3> CMS收集器

*   并发、多线程收集器，老年代收集器，标记清除算法
*   目标：是一种以最短停顿时间为目标的收集器
*   **优点**：并发收集、低停顿；
*   **缺点**：对CPU资源非常敏感，无法清除浮动垃圾，产生大量空间碎片；标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC
*   分为以下**四个流程**：
    *   初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，**需要停顿**。
    *   并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，**不需要停顿**。
    *   重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，**需要停顿**。
    *   并发清除：**不需要停顿**。

### 4> G1收集器

*   是面向服务端应用的垃圾收集器，用于新生代和老年代，特点：并行与并发、分代收集、**空间整合、可预测的停顿**

*   不牺牲吞吐量的情况下完成低停顿，极力避免对全区域进行回收，划分成多个区域region，优先回收垃圾最多的区域，整体基于标记整理算法，局部region之间基于复制算法
*   4步：初始标记、并发标记、最终标记、筛选回收

响应优先选择CMS，吞吐量高选择G1



------

## 5、GC分析

定位系统问题时，知识和经验是关键基础，数据是依据、工具是运用知识处理数据的手段

数据包括：运行日志、异常堆栈、GC日志、线程快照（thread dump、javacore文件）、堆转储快照（headdump / hprof 文件）

### 1> 调优命令

JDK监控和故障处理命令，在bin目录下有：**jps、 jstat、jmap、jhat、jstack、jinfo**

*   jps：显示虚拟机进程
    *   `jps -l -v `
*   jstat：收集虚拟机各方面的运行数据
    *   `jps-gcutil 2764`、`jstat  -gc 2764 250 20`
*   jinfo：显示虚拟机配置信息
*   jmap：生成虚拟机内存转储快照（headdump 文件）
    *   `jmap -dump:live,format=b,file=dump.hprof 28920`
*   jhat：用于分析headdump 文件，他会建立一个http/html 的服务器，让客户可以在浏览器上查看分析结果
    *   `jhat  dump.hprof`
*   jstack： 显示虚拟机线程快照
    *   ` jstack -l 11494`



#### 1.1 jps 

 格式  jps [options] [hostid]

*   一般使用：`jps -l -v `
*   options 参数如下

```bash
  -q：只输出LVMID，省略主类的名称
  -m：输出新建启动时传递给主类main()函数的参数
  -l：输出主类的全名，如果进程执行的是Jar包，输出Jar路径
  -v：输出虚拟机进程启动时JVM参数
```



#### 1.2 jstat

格式  jstat [option vmid [interval[s|ms]]  [count]   ]

*   一般使用：`jps-gcutil 2764`、`jstat  -gc 2764 250 20`
*   vmid： 进程号，interval 和count ：表示查询间隔和次数
*   options 参数如下

```bash
-class：监视类装载、卸载熟练、总空间以及类装载所消耗的时间
-gc ： 监视堆状况，包括Eden区、两个survivor区、老年代、永久代等容量、已用空间和GC 时间合计等信息
-gccapacity：监视内容和 -gc基本相同，但输出主要关注堆各个区域使用到最大，最小空间
-gcutil：监视内容和 -gc基本相同，但输出主要关注已使用空间占总空间的百分比
-gccause：与 -gcutil一样，额外输出导致上次GC产生的原因
-gcnew：监视新生代GC状况
-gcnewcapacity：监视内容和 -gcnew 基本相同，输出输出主要关注使用到的最大、最小空间
-gcold：监视老年代GC状况
-gcoldcapacity：监视内容和 -gcold 基本相同，输出输出主要关注使用到的最大、最小空间
-gcpermcapacity：输出永久代使用的最大、最小空间
-compiler：输出JIT 编译期编译过的方法、耗时等信息
-printcompilation：输出已经被JIT编译的方法
```



#### 1.3 jinfo 

格式  jinfo  [option vmid]

*   一般使用：`jinfo  -flag 11494`

```bash
-flag : 输出指定args参数的值
-flags : 不需要args参数，输出所有JVM参数的值
-sysprops : 输出系统属性，等同于System.getProperties()
```

#### 1.4 jmap 

格式  jmap  [option vmid]

*   用于生成heap dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等
*   一般使用 : `jmap -dump:live,format=b,file=dump.hprof 28920`
*   dump.hprof这个后缀是为了后续可以直接用MAT(Memory Anlysis Tool)打开。

```bash
-dump : 生成堆转储快照
-finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象
-heap : 显示Java堆详细信息
-histo : 显示堆中对象的统计信息
-permstat : to print permanent generation statistics
-F : 当-dump没有响应时，强制生成dump快照
```



#### 1.5 jhat 

格式 jhat [dumpfile] 

*   用来分析jmap生成的dump；与jmap搭配使用；jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。



#### 1.6 jstack

格式 jstack [option] LVMID

*   用于生成java虚拟机当前时刻的线程快照
*   一般使用：` jstack -l 11494`

```bash
-F : 当正常输出请求不被响应时，强制输出线程堆栈
-l : 除堆栈外，显示关于锁的附加信息
-m : 如果调用到本地方法的话，可以显示C/C++的堆栈
```

## 6、调优工具

### 1> jconsole

*   jdk /bin 目录下，单机jconsole.exe 启动启动
*   自动搜索本机运行的所有虚拟机进程，不需要用户自己在使用jps 来查询



GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。

GC Easy：推荐此工具进行gc分析；这是一个web工具,在线使用非常方便，进入官网，讲打包好的zip或者gz为后缀的压缩包上传，过一会就会拿到分析结果。

[GC Easy官网地址](http://gceasy.io)



### 2> VisualVM

jdk 集成的分析工具，在jdk /bin 目录下，单机jvisualvm.exe 启动

### 3> Oracle Java Mission Control

jdk 集成的分析工具，在jdk /bin 目录下，单机jmc.exe 启动

------

## 3> 常见问题分析

**查找CPU飙升的原因**

问题分析步骤：

*   首先，需要知道哪个进程占用CPU比较高，
*   其次，需要知道占用CPU高的那个进程中的哪些线程占用CPU比较高，
*   然后，需要知道这些线程的stack trace。

问题解决步骤：

*   1、**top**和pgrep来查看系统中Java进程的CPU占用情况。

    *   命令如下：**top -p `pgrep -d , java`**
    *   pgrep：进程号，`top -p`：进程的信息。记录下CPU占用率最高的那个进程号。

*   2、top来查看进程中CPU占用最高的那些线程

    *   **top -Hp 12345**
    *   假定12345为占用CPU高的进程号。-H是显示该进程中线程的CPU占用情况。同样，记录下CPU占用率高的那些线程号。

*   3、ctrl+H 切换到线程模式，找到占用cpu最高的线程。并把**线程号转化为十六进制**，**printf "%x\n" <线程ID>**

*   4、通过**jstack**导出Java应用中线程的stack trace（堆栈轨迹）

    *   **jstack 12345**

    

*   注意：因为top中显示的线程号是10进制，jstack的输出结果中的线程号是16进制，所以只需要把top中看到线程号转换成16进制

*   小结一下，我们通过top和jstack来找到CPU占用高的线程的stack trace





可以使用Eclipse Memory Analyzer插件分析

**Java堆溢出和泄漏**

*   **内存溢出**：程序在申请内存时,没有足够的内存空间供其使用

    *   **危害：**容易受攻击
    *   **影响因素**如下几大类： 
        *   内存中加载的数据量过于庞大，如一次从数据库取出过多数据
        *   集合类中有对对象的引用，使用完后未清空，使得JVM不能回收
        *   代码中存在死循环或循环产生过多重复的对象实体
    *   **解决方案：**
        *   修改JVM启动参数，直接增加内存
        *   检查错误日志，是否有其他异常或错误；
        *   对代码进行走查和分析，找出可能发生内存溢出的位置
        *   重点排查：数据库的取值，死循环和递归调用

*   **内存泄漏**：无法释放已申请的内存空间

    *   **危害：频繁GC、运行崩溃**

    *   影响因素如下几大类： 

        *   静态集合类引起内存泄露

        *   当集合里面的对象属性被修改后，再调用remove()方法时不起作用。

            ```java
            Set<Person> set = new HashSet<Person>();
            Person p3 = new Person("唐僧","pwd1",25);
            p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变
            set.remove(p3); //此时remove不掉，造成内存泄漏
            ```

        *   监听器。释放对象时没有删除监听器。

        *   各种连接 ，比如数据库连接

        *   单例对象持有外部对象的引用

    *   **解决办法：**使用工具jconsole分析

堆的最小值-Xms参数，最大值-Xmx参数

```java
//代码实现堆溢出：---> 无限循环创建 对象
List list =new ArrayList();
int i=0;
while(true){
    list.add(new byte[5*1024*1024]);//----------->就是这一步
    System.out.println("分配次数："+(++i))
}
```

------

**Java栈溢出**

**栈溢出SOF定义**：线程请求的栈深度超过虚拟机允许的最大深度

*   无论是由于栈帧太大还是栈容量太小，当内存无法分配时都是OOM异常。
*   虚拟机栈溢出：**深度溢出：递归方法；广度溢出：大数组，建立多线程**

```java
//代码实现栈泄漏---> 方法无限递归调用
public void add(int i){
    add(i+1);
}
```

[测试方式参考](https://blog.csdn.net/wizard_rp/article/details/73266194)

[测试方式参考](https://blog.csdn.net/haolyj98/article/details/78361867)

------

**扩展：**

GC参数

JVM的GC日志的主要参数包括如下几个：

*   `-XX:+PrintGC` 输出GC日志
*   `-XX:+PrintGCDetails` 输出GC的详细日志
*   `-XX:+PrintGCTimeStamps` 输出GC的时间戳（以基准时间的形式）
*   `-XX:+PrintGCDateStamps` 输出GC的时间戳（以日期的形式，如 2017-09-04T21:53:59.234+0800）
*   `-XX:+PrintHeapAtGC` 在进行GC的前后打印出堆的信息
*   `-Xloggc:../logs/gc.log` 日志文件的输出路径

在生产环境中，根据需要配置相应的参数来监控JVM运行情况。

------





# 参考资料

*   深入理解Java虚拟机：JVM高级特性与最佳实(最新第二版).pdf；[链接](https://pan.baidu.com/s/10LMKF09HEzcUUz9peZwePQ) 提取码: tefc 
*   [纯洁的微笑–Java 系列文章](http://www.ityouknow.com/java.html)